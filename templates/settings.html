{% extends "base.html" %}

{% block title %}Einstellungen - Mail Helper{% endblock %}

{% block content %}
<div class="container-xxl mt-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2 class="mb-0">‚öôÔ∏è Einstellungen</h2>
        <a href="/dashboard" class="btn btn-outline-secondary">‚Üê Dashboard</a>
    </div>
    
    <div class="row mt-4 g-4">
        <div class="col-12">
            <div class="card border-0 shadow-sm mb-4" style="background:linear-gradient(135deg,#0f172a,#1e1b4b);color:#f8fafc;">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                        <div>
                            <p class="text-uppercase small mb-1 opacity-75">KI-Konfiguration</p>
                            <h4 class="mb-2">Provider & Modell w√§hlen</h4>
                            <p class="mb-0" style="max-width:520px;">
                                Bestimme hier, ob lokal (Ollama) oder √ºber OpenAI/Anthropic analysiert werden soll. Cloud-Modelle nutzen automatisch die
                                stark pseudonymisierte Variante.
                            </p>
                        </div>
                        <span class="badge bg-light text-dark px-3 py-2 align-self-start">Experimentell üîß</span>
                    </div>
                    <form class="row gy-3 mt-3" method="POST" action="/settings/ai">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
                        <div class="col-12">
                            <div class="alert alert-info small mb-3">
                                <strong>3-Settings System:</strong> Embedding (Vektoren) ‚Üí Base (schnell) ‚Üí Optimize (optional, bessere Kategorisierung)
                            </div>
                        </div>
                        
                        <!-- EMBEDDING MODEL (NEU!) -->
                        <div class="col-12">
                            <h6 class="border-bottom pb-2">üîç Embedding-Model (Vektorisierung f√ºr Semantic Search & Tags)</h6>
                            <p class="small text-muted mb-3">Nur f√ºr Embeddings - nicht f√ºr Chat! Ollama, OpenAI, Mistral (Anthropic hat keine Embedding-API)</p>
                        </div>
                        <div class="col-md-6">
                            <label for="aiProviderSelectEmbedding" class="form-label">Provider</label>
                            <select class="form-select" id="aiProviderSelectEmbedding" name="ai_provider_embedding" required>
                                <option value="">-- Wird geladen --</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="aiModelSelectEmbedding" class="form-label">Modell</label>
                            <select class="form-select" id="aiModelSelectEmbedding" name="ai_model_embedding" required>
                                <option value="">-- Bitte Provider w√§hlen --</option>
                            </select>
                            <small class="text-muted d-block mt-1">z.B. all-minilm:22m, text-embedding-3-small, mistral-embed</small>
                        </div>
                        
                        <!-- BASE MODEL -->
                        <div class="col-12">
                            <h6 class="border-bottom pb-2 mt-3">‚ö° Base-Model (Schnelle Klassifikation)</h6>
                            <p class="small text-muted mb-3">Erste Analyse mit schnellem Chat-Modell</p>
                            
                            <!-- Phase Y1: Warnung Base-Model -->
                            <div class="alert alert-info mb-3">
                                ‚ÑπÔ∏è <strong>Wichtig:</strong> Das Base-Modell wird verwendet f√ºr:
                                <ul class="mb-0 mt-2 small">
                                    <li>‚úÖ Manuelle "Pass neu" Analysen (Email-Details)</li>
                                    <li>‚úÖ Fetch-Analysen (wenn Urgency Booster AUS)</li>
                                    <li>‚ùå <strong>NICHT</strong> bei aktivem Urgency Booster (nutzt Spacy statt LLM)</li>
                                </ul>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <label for="aiProviderSelectBase" class="form-label">Provider</label>
                            <select class="form-select" id="aiProviderSelectBase" name="ai_provider_base" required>
                                <option value="">-- Wird geladen --</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="aiModelSelectBase" class="form-label">Modell</label>
                            <select class="form-select" id="aiModelSelectBase" name="ai_model_base" required>
                                <option value="">-- Bitte Provider w√§hlen --</option>
                            </select>
                            <small class="text-muted d-block mt-1">z.B. llama3.2:1b, gpt-4o-mini, haiku</small>
                        </div>
                        
                        <!-- OPTIMIZE MODEL -->
                        <div class="col-12">
                            <h6 class="border-bottom pb-2 mt-3">üîß Optimize-Model (Tiefe Analyse f√ºr Scores 8-9)</h6>
                            <p class="small text-muted mb-3">Zweiter Pass mit besserem Chat-Modell bei Bedarf</p>
                        </div>
                        <div class="col-md-6">
                            <label for="aiProviderSelectOptimize" class="form-label">Provider</label>
                            <select class="form-select" id="aiProviderSelectOptimize" name="ai_provider_optimize" required>
                                <option value="">-- Wird geladen --</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="aiModelSelectOptimize" class="form-label">Modell</label>
                            <select class="form-select" id="aiModelSelectOptimize" name="ai_model_optimize" required>
                                <option value="">-- Bitte Provider w√§hlen --</option>
                            </select>
                            <small class="text-muted d-block mt-1">z.B. llama3.2:3b, gpt-4o, sonnet</small>
                        </div>
                        
                        <div class="col-12">
                            <div id="aiProviderWarning" class="alert alert-warning d-none mb-0"></div>
                        </div>
                        <div class="col-12">
                            <div class="alert alert-warning small mb-3">
                                <strong>‚ö†Ô∏è Wichtig:</strong> Wenn du das Embedding-Model √§nderst, m√ºssen ALLE Emails neu verarbeitet werden f√ºr konsistente Semantic Search!
                            </div>
                        </div>
                        <div class="col-12 d-flex justify-content-between gap-2">
                            <button type="button" id="batchReprocessBtn" class="btn btn-outline-warning">
                                üîÑ Alle Emails neu embedden
                            </button>
                            <button type="submit" class="btn btn-light text-dark px-4">Speichern</button>
                        </div>
                    </form>
                </div>
            </div>

            <div class="card border-0 shadow-sm mb-4" style="background:linear-gradient(135deg,#0f172a,#1e1b4b);color:#f8fafc;">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-4">
                        <div>
                            <p class="text-uppercase small mb-1 opacity-75">üß† Machine Learning</p>
                            <h4 class="mb-2">Training & Feedback-Loop</h4>
                            <p class="mb-0" style="max-width:520px;">
                                Deine Korrektionen verbessern das System kontinuierlich. Wenn du ‚â•5 Emails korrigiert hast, kannst du neue Modelle trainieren.
                            </p>
                        </div>
                        <span class="badge bg-info px-3 py-2 align-self-start">Live üöÄ</span>
                    </div>

                    <div class="row g-3" id="trainingStatsContainer">
                        <div class="col-md-6">
                            <div class="p-3 bg-dark rounded">
                                <small class="text-uppercase opacity-75">Korrektionen gespeichert</small>
                                <h5 id="correctionsCount" class="mb-0">-- <span class="text-muted">/ ~50</span></h5>
                                <div class="progress mt-2" style="height:6px;">
                                    <div id="correctionsBar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                                </div>
                                <small class="text-muted d-block mt-2">Zum Trainieren: mind. 5 Korrektionen</small>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="p-3 bg-dark rounded">
                                <small class="text-uppercase opacity-75">Trainierte Modelle</small>
                                <h5 id="trainedModelsCount" class="mb-2">-- / 3</h5>
                                <div id="trainedModelsList" class="small">
                                    <small class="text-muted">wird geladen...</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-12">
                            <div id="lastCorrectionInfo" class="alert alert-secondary d-none">
                                <small>Letzte Korrektur: <strong id="lastCorrectionDate">--</strong></small>
                            </div>
                        </div>
                        <div class="col-12 d-flex justify-content-end gap-2">
                            <button id="retrainBtn" class="btn btn-primary">
                                üöÄ Neue Modelle trainieren
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card border-0 shadow-sm mb-4" style="background:linear-gradient(135deg,#0f172a,#1e1b4b);color:#f8fafc;">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-3">
                        <div>
                            <p class="text-uppercase small mb-1 opacity-75">üì• Fetch Konfiguration</p>
                            <h4 class="mb-2">Mail-Abruf steuern</h4>
                            <p class="mb-0" style="max-width:600px;">
                                Kontrolliere wie viele Mails pro Ordner und insgesamt abgerufen werden. 
                                Delta-Sync fetcht nur neue Mails seit letztem Sync.
                            </p>
                        </div>
                        <span class="badge bg-light text-dark px-3 py-2 align-self-start">Phase 13C Part 4</span>
                    </div>
                    <form class="row gy-3" method="POST" action="/settings/fetch-config" id="fetchConfigForm">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
                        <input type="hidden" name="account_id" id="formAccountId" value="" />
                        
                        <div class="col-md-6">
                            <label for="mailsPerFolder" class="form-label">Mails pro Ordner (Standard: 100)</label>
                            <input type="number" class="form-control" id="mailsPerFolder" name="mails_per_folder" 
                                   value="{{ user_prefs.get('mails_per_folder', 100) }}" min="10" max="1000" step="10">
                            <small class="text-muted">Bei FULL SYNC wird dieses Limit angewandt</small>
                        </div>
                        
                        <div class="col-md-6">
                            <label for="maxTotalMails" class="form-label">Max. Gesamt (0 = unbegrenzt)</label>
                            <input type="number" class="form-control" id="maxTotalMails" name="max_total_mails" 
                                   value="{{ user_prefs.get('max_total_mails', 0) }}" min="0" max="10000" step="50">
                            <small class="text-muted">0 bedeutet: Hole ALLE Mails aus allen Ordnern</small>
                        </div>
                        
                        <div class="col-12">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="useDeltaSync" name="use_delta_sync" 
                                       {% if user_prefs.get('use_delta_sync', true) %}checked{% endif %}>
                                <label class="form-check-label" for="useDeltaSync">
                                    <strong>Delta-Sync aktivieren</strong>
                                    <small class="d-block text-muted">Nur neue Mails abrufen (spart Bandbreite & Zeit)</small>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Phase 13C Part 5: Erweiterte Filter -->
                        <div class="col-12">
                            <hr class="my-3 opacity-25">
                            <h6 class="text-uppercase small opacity-75 mb-3">üìã Erweiterte Filter</h6>
                            <small class="text-muted d-block mb-3">
                                Diese Filter gelten bei <strong>jedem Fetch</strong> (au√üer SINCE bei Delta-Sync).
                                Perfekt um gro√üe Accounts schrittweise zu synchronisieren.
                            </small>
                        </div>
                        
                        <!-- SINCE Datum -->
                        <div class="col-md-6 mb-3">
                            <label for="sinceDate" class="form-label">Nur Mails ab Datum</label>
                            <input type="date" class="form-control bg-dark text-light border-secondary" 
                                   id="sinceDate" name="since_date"
                                   value="{{ user_prefs.get('since_date', '')|string if user_prefs.get('since_date') else '' }}">
                            <small class="text-muted d-block mt-1">
                                Leer = alle Mails. Empfohlen: 2025-12-01 f√ºr neue Accounts<br>
                                <strong>Hinweis:</strong> Bei Delta-Sync deaktiviert (UID-Range effizienter)
                            </small>
                        </div>
                        
                        <!-- Nur Ungelesene -->
                        <div class="col-md-6 mb-3">
                            <div class="form-check form-switch mt-4">
                                <input class="form-check-input" type="checkbox" id="unseenOnly" name="unseen_only"
                                       {% if user_prefs.get('unseen_only', false) %}checked{% endif %}>
                                <label class="form-check-label" for="unseenOnly">
                                    <strong>Nur ungelesene Mails</strong>
                                    <small class="d-block text-muted">IMAP UNSEEN Filter - spart massiv Zeit</small>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Ordner-Auswahl -->
                        <div class="col-12 mb-3">
                            <label class="form-label">Ordner-Filter</label>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="alert alert-success mb-0">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <strong>‚úÖ Nur diese Ordner (Include)</strong>
                                            <div class="btn-group btn-group-sm" role="group">
                                                <button type="button" class="btn btn-outline-success btn-sm" id="selectAllIncludes">
                                                    <i class="bi bi-check-all"></i> Alle
                                                </button>
                                                <button type="button" class="btn btn-outline-secondary btn-sm" id="selectNoneIncludes">
                                                    <i class="bi bi-x"></i> Keine
                                                </button>
                                            </div>
                                        </div>
                                        <small class="d-block text-muted mb-2">
                                            üí° Keine Auswahl = Alle Ordner werden synchronisiert
                                        </small>
                                        <div id="includeFoldersContainer" class="mt-2" style="max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: white;">
                                            <small class="text-muted">W√§hle einen Account und klicke "Ordner laden"</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="alert alert-warning mb-0">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <strong>‚ùå Diese Ordner ignorieren (Exclude)</strong>
                                            <div class="btn-group btn-group-sm" role="group">
                                                <button type="button" class="btn btn-outline-warning btn-sm" id="selectAllExcludes">
                                                    <i class="bi bi-check-all"></i> Alle
                                                </button>
                                                <button type="button" class="btn btn-outline-secondary btn-sm" id="selectNoneExcludes">
                                                    <i class="bi bi-x"></i> Keine
                                                </button>
                                            </div>
                                        </div>
                                        <small class="d-block text-muted mb-2">
                                            Standard: Keine Ordner ausgeschlossen. W√§hle gezielt aus.
                                        </small>
                                        <div id="excludeFoldersContainer" class="mt-2" style="max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: white;">
                                            <small class="text-muted">Keine Ausschl√ºsse gesetzt</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2">
                                <label for="folderAccountSelect" class="form-label small">Account f√ºr Filter ausw√§hlen:</label>
                                <select class="form-select form-select-sm bg-dark text-light border-secondary d-inline-block w-auto" 
                                        id="folderAccountSelect" required>
                                    <option value="">-- Account w√§hlen --</option>
                                    {% for account in mail_accounts %}
                                    <option value="{{ account.id }}">{{ account.name }}</option>
                                    {% endfor %}
                                </select>
                                <button type="button" class="btn btn-sm btn-outline-light" id="loadFoldersBtn">
                                    üìÇ Ordner laden
                                </button>
                                <small class="d-block text-muted mt-1">Filter gelten nur f√ºr den gew√§hlten Account</small>
                            </div>
                        </div>
                        
                        <div class="col-12">
                            <div class="alert alert-info mb-0 small">
                                <strong>üí° Tipp:</strong> Nutze "Quick Count" (siehe Mail-Accounts unten) um zu sehen wie viele Mails remote sind, 
                                bevor du fetchst. Bei vielen Tausend Mails empfiehlt sich Delta-Sync!
                            </div>
                        </div>
                        
                        <!-- Phase 13C Part 5: Fetch-Vorschau Counter -->
                        <div class="col-12" id="fetchPreviewContainer" style="display: none;">
                            <div class="alert alert-success mb-0">
                                <strong>üìä Gesch√§tzte Mails mit aktuellen Filtern:</strong>
                                <span id="fetchPreviewCount" class="badge bg-success fs-5 ms-2">0</span>
                                <small class="d-block text-muted mt-1" id="fetchPreviewDetails"></small>
                            </div>
                        </div>
                        
                        <div class="col-12 d-flex justify-content-end gap-2">
                            <button type="submit" class="btn btn-light text-dark px-4">Speichern</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- AI & Trusted Senders Cards -->
            <div class="row g-3 mb-4">
                <div class="col-md-6">
                    <div class="card border-0 shadow-sm h-100" style="background:linear-gradient(135deg,#1e293b,#0f172a);color:#f8fafc;">
                        <div class="card-body">
                            <div class="d-flex flex-column h-100">
                                <div class="flex-grow-1">
                                    <p class="text-uppercase small mb-1 opacity-75">ü§ñ AI-Steuerung</p>
                                    <h5 class="mb-2">AI beim Mail-Abruf</h5>
                                    <p class="mb-0 small">Analyse-Modi, Anonymisierung & Booster konfigurieren</p>
                                </div>
                                <a href="/mail-fetch-config" class="btn btn-light mt-3">Konfigurieren ‚Üí</a>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card border-0 shadow-sm h-100" style="background:linear-gradient(135deg,#064e3b,#022c22);color:#f8fafc;">
                        <div class="card-body">
                            <div class="d-flex flex-column h-100">
                                <div class="flex-grow-1">
                                    <p class="text-uppercase small mb-1 opacity-75">üì¨ VIP-Management</p>
                                    <h5 class="mb-2">Trusted Senders</h5>
                                    <p class="mb-0 small">Vertrauensw√ºrdige Absender f√ºr automatische VIP-Behandlung</p>
                                </div>
                                <a href="/whitelist" class="btn btn-light mt-3">Verwalten ‚Üí</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <h4>Mail-Accounts</h4>
            
            {% if mail_accounts %}
            <div class="table-responsive">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Acc-ID</th>
                            <th>User-ID</th>
                            <th>Name</th>
                            <th>Server</th>
                            <th>Port</th>
                            <th>Benutzer</th>
                            <th>Status</th>
                            <th>Abruf-Einstellungen</th>
                            <th>Aktionen</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for account in mail_accounts %}
                        <tr>
                            <td><code class="text-muted">{{ account.id }}</code></td>
                            <td><code class="text-muted">{{ account.user_id }}</code></td>
                            <td>
                                <strong>{{ account.name }}</strong>
                                {% if account.fetch_since_date or account.fetch_unseen_only or account.fetch_include_folders or account.fetch_exclude_folders %}
                                <span class="badge bg-warning text-dark ms-1" title="Dieser Account hat aktive Fetch-Filter">‚öôÔ∏è Filter</span>
                                {% endif %}
                            </td>
                            <td>{{ account.imap_server }}</td>
                            <td>{{ account.imap_port }}</td>
                            <td>{{ account.imap_username }}</td>
                            <td>
                                {% if account.enabled %}
                                <span class="badge bg-success">Aktiv</span>
                                {% else %}
                                <span class="badge bg-secondary">Inaktiv</span>
                                {% endif %}
                            </td>
                            <td>
                                <div class="d-flex flex-column gap-1">
                                    <div class="d-flex align-items-center gap-1 flex-wrap">
                                        <!-- Phase 22: Anonymisierung Badge -->
                                        {% if account.anonymize_with_spacy %}
                                        <span class="badge bg-info" style="font-size: 0.75rem;" title="Emails werden anonymisiert (PII-Schutz)">
                                            üõ°Ô∏è Anon
                                        </span>
                                        {% endif %}
                                        
                                        <!-- Effective AI Mode Badge -->
                                        {% set mode = account.effective_ai_mode %}
                                        {% if mode == "spacy_booster" %}
                                        <span class="badge bg-warning text-dark" style="font-size: 0.75rem;" title="Urgency Booster (Spacy NER auf Original)">
                                            ‚ö° Booster
                                        </span>
                                        {% elif mode == "llm_anon" %}
                                        <span class="badge bg-primary" style="font-size: 0.75rem;" title="LLM auf anonymisierten Daten">
                                            ü§ñ AI-Anon
                                        </span>
                                        {% elif mode == "llm_original" %}
                                        <span class="badge bg-success" style="font-size: 0.75rem;" title="LLM auf Original-Daten">
                                            ü§ñ AI-Orig
                                        </span>
                                        {% elif mode == "none" %}
                                        <span class="badge bg-secondary" style="font-size: 0.75rem;" title="Keine AI-Analyse">
                                            ‚ùå Keine AI
                                        </span>
                                        {% endif %}
                                    </div>
                                    <small class="text-muted" style="font-size: 0.7rem;">
                                        <a href="/mail-fetch-config" class="text-decoration-none">‚Üí √Ñndern</a>
                                    </small>
                                </div>
                            </td>
                            <td>
                                <div class="btn-group btn-group-sm flex-wrap" role="group" aria-label="Mail-Aktionen" style="gap:0.25rem;">
                                    <a href="/settings/mail-account/{{ account.id }}/edit" class="btn btn-info">Bearbeiten</a>
                                    <button type="button" class="btn btn-outline-primary quick-count-btn" data-account-id="{{ account.id }}" data-account-name="{{ account.name }}">üìä Count</button>
                                    <button type="button" class="btn btn-success fetch-mails-btn" data-account-id="{{ account.id }}" data-account-name="{{ account.name }}">Abrufen</button>
                                    
                                    <!-- Sync Dropdown -->
                                    <div class="btn-group btn-group-sm" role="group">
                                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" title="Synchronisations-Optionen">
                                            üîÑ Sync
                                        </button>
                                        <ul class="dropdown-menu dropdown-menu-end">
                                            <li><a class="dropdown-item sync-flags-btn" href="#" data-account-id="{{ account.id }}" data-account-name="{{ account.name }}">
                                                üè∑Ô∏è Flags synchronisieren
                                                <small class="d-block text-muted">Gelesen/Ungelesen-Status</small>
                                            </a></li>
                                            <li><a class="dropdown-item sync-server-btn" href="#" data-account-id="{{ account.id }}" data-account-name="{{ account.name }}">
                                                üì° Server-Scan
                                                <small class="d-block text-muted">Verschobene/gel√∂schte Mails erkennen</small>
                                            </a></li>
                                        </ul>
                                    </div>
                                    
                                    <button type="button" class="btn btn-outline-danger purge-mails-btn" data-account-id="{{ account.id }}" data-account-name="{{ account.name }}">Daten l√∂schen</button>
                                    <form method="POST" action="/settings/mail-account/{{ account.id }}/delete" style="display: inline;" class="delete-account-form">
                                        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
                                        <button type="submit" class="btn btn-danger">L√∂schen</button>
                                    </form>
                                </div>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            {% else %}
            <p class="text-muted">Noch keine Mail-Accounts konfiguriert</p>
            {% endif %}
            
            <a href="/settings/mail-account/select-type" class="btn btn-primary mt-3">Neuen Account hinzuf√ºgen</a>
            
            <hr class="my-5">
            
            <h4>üîê Sicherheit</h4>
            
            <div class="card mb-3">
                <div class="card-body">
                    <h6 class="card-title">Passwort √§ndern</h6>
                    <p class="text-muted mb-2">√Ñndere dein Passwort mit Zero-Knowledge Sicherheit (KEK-Neuableitung ohne E-Mail-Neu-Verschl√ºsselung)</p>
                    <a href="/settings/password" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-key"></i> Passwort √§ndern
                    </a>
                </div>
            </div>
            
            <h4 class="mt-4">Zwei-Faktor-Authentifizierung (2FA)</h4>
            {% if totp_enabled %}
            <div class="alert alert-success">‚úì 2FA ist aktiviert</div>
            <p>Dein Account ist mit TOTP gesch√ºtzt.</p>
            <form method="POST" action="/settings/2fa/recovery-codes/regenerate" class="mt-3" id="regenerateRecoveryForm">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
                <button type="submit" class="btn btn-outline-warning">
                    <i class="fas fa-sync"></i> Recovery-Codes regenerieren
                </button>
            </form>
            {% else %}
            <div class="alert alert-warning">‚ö†Ô∏è 2FA ist Pflicht - bitte aktivieren</div>
            <a href="/settings/2fa/setup" class="btn btn-warning">2FA aktivieren</a>
            {% endif %}
            
            <hr class="my-5">
            
            <div>
                <a href="/dashboard" class="btn btn-secondary">Zur√ºck zum Dashboard</a>
            </div>
        </div>
    </div>
</div>

<script nonce="{{ csp_nonce() }}">
function confirmRegenerate() {
    return confirm(
        '‚ö†Ô∏è Wirklich neue Recovery-Codes generieren?\n\n' +
        'ACHTUNG:\n' +
        '‚Ä¢ Alle alten Recovery-Codes werden ung√ºltig\n' +
        '‚Ä¢ Du musst die neuen Codes sofort sichern\n' +
        '‚Ä¢ Dieser Vorgang kann nicht r√ºckg√§ngig gemacht werden\n\n' +
        'Fortfahren?'
    );
}

function formatTime(seconds) {
    if (seconds < 60) return seconds + 's';
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    if (mins < 60) return mins + 'm ' + secs + 's';
    const hours = Math.floor(mins / 60);
    return hours + 'h ' + (mins % 60) + 'm';
}

function fetchMails(evt, accountId, accountName) {
    const btn = evt ? evt.target : null;
    const originalLabel = btn ? btn.textContent : '';
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Job wird gestartet...';
    }

    fetch(`/mail-account/${accountId}/fetch`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'queued') {
            alert(`üïí ${accountName}: Analyse l√§uft im Hintergrund.`);
            if (data.job_id) {
                pollJobStatus(data.job_id, accountName, btn, originalLabel);
            }
            return;
        }
        if (data.status === 'ok') {
            alert(`‚úÖ ${accountName}: ${data.message || 'Fertig.'}`);
        } else {
            throw new Error(data.error || 'Unbekannter Fehler');
        }
    })
    .catch(err => {
        alert(`‚ùå Fehler: ${err}`);
        if (btn) {
            btn.disabled = false;
            btn.textContent = originalLabel || 'Abrufen';
        }
    });
}

let analysisModal = null;

function getAnalysisModal() {
    if (!analysisModal) {
        analysisModal = new bootstrap.Modal(document.getElementById('progressModal'), {backdrop: 'static', keyboard: false});
    }
    return analysisModal;
}

// Race Condition Protection: Track aktive Job-ID statt Boolean
// GE√ÑNDERT 2026-01-05: Verhindert Modal-Updates von mehreren parallelen Jobs
// Siehe: doc/offen/REFACTORING_JOB_MODAL_TRACKING.md
let currentActiveJobId = null;

function pollJobStatus(jobId, accountName, btn, originalLabel, attempt = 0, startTime = Date.now(), emailStartTime = null, lastEmailIndex = null) {
    // Job-Ownership Management: Bei erstem Aufruf √ºbernimmt dieser Job das Modal
    if (attempt === 0) {
        if (currentActiveJobId && currentActiveJobId !== jobId) {
            console.log(`‚ö†Ô∏è Job ${jobId} √ºbernimmt Modal von ${currentActiveJobId}`);
        }
        currentActiveJobId = jobId;
    }
    
    // Ignoriere Updates von nicht-aktiven Jobs (verhindert UI-Springen)
    if (currentActiveJobId !== jobId) {
        console.log(`üõë Poll ignoriert: Job ${jobId} nicht aktiv (aktiv: ${currentActiveJobId})`);
        return;
    }
    
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const modal = getAnalysisModal();
    if (attempt === 0) modal.show();
    
    const perEmailTimeout = 600;  // 10 Minuten pro E-Mail
    
    fetch(`/jobs/${jobId}`, {cache: 'no-store'})
        .then(r => {
            if (r.status === 404) {
                throw new Error('Job nicht gefunden');
            }
            if (r.status === 429) {
                // Rate-limit: warte l√§nger und versuche erneut
                console.warn('Rate-Limit erreicht, warte 30s...');
                setTimeout(() => pollJobStatus(jobId, accountName, btn, originalLabel, attempt + 1, startTime, emailStartTime, lastEmailIndex), 30000);
                return null;
            }
            if (!r.ok) {
                throw new Error(`HTTP ${r.status}`);
            }
            return r.json();
        })
        .then(status => {
            // Skip wenn Rate-Limit und Retry gestartet
            if (status === null) {
                return;
            }
            const currentIdx = status.current_email_index || 0;
            
            // Wenn neue E-Mail begonnen wird, Timer zur√ºcksetzen
            if (lastEmailIndex !== null && currentIdx > lastEmailIndex) {
                emailStartTime = Date.now();
            }
            if (emailStartTime === null) {
                emailStartTime = Date.now();
            }
            
            const emailElapsed = Math.floor((Date.now() - emailStartTime) / 1000);
            const emailRemaining = perEmailTimeout - emailElapsed;
            
            document.getElementById('elapsedTime').textContent = formatTime(elapsed);
            document.getElementById('remainingTime').textContent = emailRemaining > 0 ? '~' + formatTime(emailRemaining) : 'abgelaufen!';
            
            if (status.state === 'done') {
                const saved = status.saved ?? 0;
                const processed = status.processed ?? 0;
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressPercent').textContent = '100%';
                document.getElementById('emailCount').textContent = `${status.current_email_index || status.total_emails || '?'}/${status.total_emails || '?'}`;
                document.getElementById('progressText').textContent = `‚úÖ ${accountName}: Fertig!`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusTitle').textContent = '‚úÖ Analyse abgeschlossen';
                document.getElementById('statusDetails').textContent = `${saved} neue / ${processed} verarbeitet.`;
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    const modal = getAnalysisModal();
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel || 'Abrufen';
                    }
                });
                return;
            }
            if (status.state === 'error') {
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressBar').classList.add('bg-danger');
                document.getElementById('emailCount').textContent = `${status.current_email_index || '?'}/${status.total_emails || '?'}`;
                document.getElementById('progressText').textContent = `‚ùå ${accountName}: ${status.message || 'Job fehlgeschlagen.'}`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusMessage').querySelector('.alert').className = 'alert alert-danger mb-0';
                document.getElementById('statusTitle').textContent = '‚ùå Fehler bei der Analyse';
                document.getElementById('statusDetails').textContent = status.message || 'Job fehlgeschlagen.';
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    const modal = getAnalysisModal();
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel || 'Abrufen';
                    }
                });
                return;
            }
            
            const totalEmails = status.total_emails || 1;
            const currentSubject = status.current_subject || '';
            
            document.getElementById('emailCount').textContent = `${currentIdx}/${totalEmails}`;
            
            if (emailRemaining <= 0) {
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressBar').classList.add('bg-danger');
                document.getElementById('progressText').textContent = `‚ùå ${accountName}: Timeout √ºberschritten.`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusMessage').querySelector('.alert').className = 'alert alert-warning mb-0';
                document.getElementById('statusTitle').textContent = '‚è±Ô∏è Timeout √ºberschritten';
                document.getElementById('statusDetails').textContent = `Die Analyse konnte nicht within ${Math.floor((Date.now() - startTime) / 1000)}s abgeschlossen werden.`;
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    const modal = getAnalysisModal();
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel || 'Abrufen';
                    }
                });
                return;
            }
            
            const progress = Math.min(95, (currentIdx / totalEmails) * 100);
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('progressPercent').textContent = Math.floor(progress) + '%';
            const subjectDisplay = currentSubject ? ` - ${currentSubject}` : '';
            document.getElementById('progressText').textContent = `${accountName}: Mail ${currentIdx}/${totalEmails}${subjectDisplay}`;
            
            // üöÄ Polling-Interval auf 5s erh√∂ht (von 2s) - verhindert Rate-Limit-Hits
            // Bei langsamen Jobs (Ollama-Embeddings) sind 2s zu aggressiv
            setTimeout(() => pollJobStatus(jobId, accountName, btn, originalLabel, attempt + 1, startTime, emailStartTime, currentIdx), 5000);
        })
        .catch(err => {
            modal.hide();
            currentActiveJobId = null;  // Reset job tracking bei Error
            alert(`‚ùå Status-Check fehlgeschlagen: ${err}`);
            if (btn) {
                btn.disabled = false;
                btn.textContent = originalLabel || 'Abrufen';
            }
        });
}

function quickCount(evt, accountId, accountName) {
    const btn = evt ? evt.target : null;
    const originalLabel = btn ? btn.textContent : '';
    if (btn) {
        btn.disabled = true;
        btn.textContent = '‚è≥ Z√§hle...';
    }

    fetch(`/account/${accountId}/mail-count`, {
        method: 'GET',
        headers: {
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
    })
    .then(r => r.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Format folder details
        let folderDetails = Object.entries(data.folders || {})
            .map(([folder, counts]) => `  ‚Ä¢ ${folder}: ${counts.total} Mails (${counts.unseen} ungelesen)`)
            .join('\n');
        
        const summary = data.summary || {};
        const message = `üìä ${accountName}\n\n` +
            `Remote (Server):\n${folderDetails}\n\n` +
            `Gesamt Remote: ${summary.total_remote || 0} Mails\n` +
            `Ungelesen: ${summary.total_unseen || 0}\n` +
            `Lokal in DB: ${summary.total_local || 0}\n` +
            `Delta: ${summary.delta || 0} Mails fehlen lokal`;
        
        alert(message);
        
        if (btn) {
            btn.disabled = false;
            btn.textContent = originalLabel;
        }
    })
    .catch(err => {
        alert(`‚ùå Fehler beim Z√§hlen: ${err}`);
        if (btn) {
            btn.disabled = false;
            btn.textContent = originalLabel || 'üìä Count';
        }
    });
}

function purgeMails(evt, accountId, accountName) {
    if (!confirm(`Alle lokal gespeicherten Mails f√ºr ${accountName} l√∂schen?`)) {
        return;
    }
    const btn = evt ? evt.target : null;
    const originalLabel = btn ? btn.textContent : '';
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'L√∂sche...';
    }

    fetch(`/mail-account/${accountId}/purge`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'ok') {
            alert(`üßπ ${accountName}: ${data.raw_deleted} Raw / ${data.processed_deleted} Processed gel√∂scht.`);
        } else {
            alert(`‚ùå Fehler: ${data.error || 'Unbekannter Fehler'}`);
        }
    })
    .catch(e => alert(`‚ùå Fehler: ${e}`))
    .finally(() => {
        if (btn) {
            btn.disabled = false;
            btn.textContent = originalLabel || 'Daten l√∂schen';
        }
    });
}

// Flag-Sync: Synchronisiert nur Gelesen/Ungelesen-Status vom Server
// N√ºtzlich wenn Mails auf anderem Client gelesen wurden
function syncFlags(evt, accountId, accountName) {
    const btn = evt ? evt.target : null;
    const originalLabel = btn ? btn.textContent : '';
    if (btn) {
        btn.disabled = true;
        btn.textContent = '‚è≥ Sync...';
    }

    fetch(`/mail-account/${accountId}/sync-flags`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
    })
    .then(async r => {
        // Pr√ºfe HTTP-Status BEVOR json() aufgerufen wird
        if (!r.ok) {
            const text = await r.text();
            console.error('Sync-Flags Error:', r.status, text.substring(0, 500));
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    })
    .then(data => {
        if (data.status === 'ok') {
            const updated = data.updated || 0;
            const total = data.total || 0;
            if (updated > 0) {
                alert(`üîÑ ${accountName}: ${updated} von ${total} Mails aktualisiert.`);
            } else {
                alert(`‚úÖ ${accountName}: Alle ${total} Flags sind aktuell.`);
            }
        } else {
            alert(`‚ùå Fehler: ${data.error || 'Unbekannter Fehler'}`);
        }
    })
    .catch(e => alert(`‚ùå Fehler: ${e}`))
    .finally(() => {
        if (btn) {
            btn.disabled = false;
            btn.textContent = originalLabel || 'üè∑Ô∏è Flags synchronisieren';
        }
    });
}

// Server-Scan: Vollst√§ndiger Scan aller Mails auf dem Server
// Erkennt verschobene und gel√∂schte Mails
function syncServer(evt, accountId, accountName) {
    const btn = evt ? evt.target : null;
    const originalLabel = btn ? btn.textContent : '';
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Scanning...';
    }

    fetch(`/mail-account/${accountId}/sync-server`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
    })
    .then(async r => {
        if (!r.ok) {
            const text = await r.text();
            console.error('Sync-Server Error:', r.status, text.substring(0, 500));
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    })
    .then(data => {
        if (data.status === 'ok' || data.status === 'partial') {
            let msg = `üì° ${accountName}: Server-Scan abgeschlossen\n\n`;
            msg += `üìÅ ${data.folders_scanned} Ordner gescannt\n`;
            msg += `üìß ${data.mails_on_server} Mails auf Server\n`;
            msg += `‚úÖ ${data.already_fetched} bereits lokal\n`;
            
            if (data.new_mails > 0) {
                msg += `üÜï ${data.new_mails} neue Mails gefunden\n`;
            }
            if (data.moved_mails > 0) {
                msg += `üìÅ ${data.moved_mails} verschobene Mails erkannt\n`;
            }
            if (data.deleted_mails > 0) {
                msg += `üóëÔ∏è ${data.deleted_mails} gel√∂schte Mails markiert\n`;
            }
            
            if (data.errors && data.errors.length > 0) {
                msg += `\n‚ö†Ô∏è Fehler: ${data.errors.join(', ')}`;
            }
            
            alert(msg);
            
            // Reload page to show updated counts
            if (data.moved_mails > 0 || data.deleted_mails > 0) {
                location.reload();
            }
        } else {
            alert(`‚ùå Fehler: ${data.error || 'Unbekannter Fehler'}`);
        }
    })
    .catch(e => alert(`‚ùå Fehler: ${e}`))
    .finally(() => {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalLabel || 'üì° Server-Scan';
        }
    });
}

async function initializeProviders() {
    try {
        console.log('üîç Fetching available providers...');
        const response = await fetch('/api/available-providers', {credentials: 'include'});
        console.log('üì° Response status:', response.status, response.statusText);
        
        if (!response.ok) {
            console.error('‚ùå API call failed:', response.status, response.statusText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Providers loaded:', data.providers);
        const providers = data.providers || [];
        
        const savedValues = window.savedAIValues || {
            Embedding: { provider: 'ollama', model: 'all-minilm:22m' },
            Base: { provider: 'ollama', model: 'llama3.2:1b' },
            Optimize: { provider: 'ollama', model: 'llama3.2:3b' }
        };
        
        // Provider-Dropdowns f√ºr alle 3 Settings f√ºllen
        ['Embedding', 'Base', 'Optimize'].forEach(pass => {
            const select = document.getElementById(`aiProviderSelect${pass}`);
            if (select) {
                select.innerHTML = '';
                if (providers.length === 0) {
                    select.innerHTML = '<option value="">Keine Provider verf√ºgbar</option>';
                } else {
                    providers.forEach(p => {
                        // Anthropic hat keine Embedding-API ‚Üí ausblenden f√ºr Embedding
                        if (pass === 'Embedding' && p.id === 'anthropic') {
                            return; // Skip Anthropic f√ºr Embedding
                        }
                        
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = `${p.name} - ${p.description}`;
                        if (p.id === savedValues[pass].provider) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
                }
                
                if (savedValues[pass].provider) {
                    updateModels(pass);
                }
            }
        });
    } catch (err) {
        console.error('‚ùå Error loading providers:', err);
        alert(`Provider konnten nicht geladen werden: ${err.message}`);
    }
}

async function updateModels(pass) {
    const providerSelect = document.getElementById(`aiProviderSelect${pass}`);
    const modelSelect = document.getElementById(`aiModelSelect${pass}`);
    
    if (!providerSelect || !modelSelect) return;
    
    const provider = providerSelect.value;
    if (!provider) {
        modelSelect.innerHTML = '<option value="">-- Bitte Provider w√§hlen --</option>';
        return;
    }
    
    try {
        modelSelect.innerHTML = '<option value="">Modelle werden geladen...</option>';
        
        // NEU: Nutze dynamische Model Discovery
        const response = await fetch(`/api/models/${provider}`, {credentials: 'include'});
        const data = await response.json();
        let models = data.models || [];
        
        // Filter nach Model-Typ
        if (pass === 'Embedding') {
            // Nur Embedding-Modelle
            models = models.filter(m => m.type === 'embedding');
        } else {
            // BASE & OPTIMIZE: Nur Chat-Modelle
            models = models.filter(m => m.type === 'chat');
        }
        
        const savedModel = (window.savedAIValues && window.savedAIValues[pass]) ? window.savedAIValues[pass].model : null;
        
        modelSelect.innerHTML = '';
        if (models.length === 0) {
            if (pass === 'Embedding' && provider === 'anthropic') {
                modelSelect.innerHTML = '<option value="">‚ö†Ô∏è Anthropic hat keine Embedding-API</option>';
            } else {
                modelSelect.innerHTML = '<option value="">Keine Modelle verf√ºgbar</option>';
            }
        } else {
            models.forEach(m => {
                const option = document.createElement('option');
                option.value = m.id;
                
                // Formatierung mit Typ-Hinweis
                const displayName = m.display_name || m.name || m.id;
                const typeLabel = m.type === 'embedding' ? 'üîç' : 'üí¨';
                option.textContent = `${typeLabel} ${displayName}`;
                option.textContent = `${typeLabel} ${displayName}`;
                
                if (savedModel && m.id === savedModel) {
                    option.selected = true;
                }
                modelSelect.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Error loading models:', err);
        modelSelect.innerHTML = '<option value="">Fehler beim Laden von Modellen</option>';
    }
}

async function loadTrainingStats() {
    try {
        const response = await fetch('/api/training-stats');
        if (!response.ok) return;
        
        const data = await response.json();
        
        const correctionsCount = data.corrections_count || 0;
        const maxCorrections = 50;
        const progressPercent = Math.min(100, (correctionsCount / maxCorrections) * 100);
        
        document.getElementById('correctionsCount').textContent = correctionsCount + ' ';
        document.getElementById('correctionsBar').style.width = progressPercent + '%';
        
        const trainedCount = data.trained_models_count || 0;
        document.getElementById('trainedModelsCount').textContent = trainedCount + ' / 3';
        
        if (data.trained_models && data.trained_models.length > 0) {
            const modelsList = data.trained_models.map(m => {
                const date = new Date(m.modified * 1000).toLocaleDateString('de-DE');
                return `<div class="badge bg-success">${m.name} ‚úì (${date})</div>`;
            }).join('');
            document.getElementById('trainedModelsList').innerHTML = modelsList;
        } else {
            document.getElementById('trainedModelsList').innerHTML = '<small class="text-muted">Noch keine trainierten Modelle</small>';
        }
        
        if (data.last_correction_date) {
            const corrDate = new Date(data.last_correction_date);
            document.getElementById('lastCorrectionDate').textContent = corrDate.toLocaleDateString('de-DE', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            document.getElementById('lastCorrectionInfo').classList.remove('d-none');
        }
        
        const retrainBtn = document.getElementById('retrainBtn');
        if (data.ready_for_training) {
            retrainBtn.disabled = false;
            retrainBtn.textContent = `üöÄ Neue Modelle trainieren (${correctionsCount} Korrektionen)`;
        } else {
            retrainBtn.disabled = true;
            retrainBtn.textContent = `üöÄ Noch ${5 - correctionsCount} Korrektionen n√∂tig`;
        }
    } catch (err) {
        console.error('Error loading training stats:', err);
    }
}

async function triggerRetraining() {
    const btn = document.getElementById('retrainBtn');
    const originalText = btn.textContent;
    
    btn.disabled = true;
    btn.textContent = '‚è≥ Training l√§uft...';
    
    try {
        const response = await fetch('/retrain', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
            }
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            alert(`‚úÖ ${data.message}`);
            await loadTrainingStats();
        } else if (data.status === 'no_data') {
            alert(`‚ö†Ô∏è ${data.message}`);
            btn.disabled = false;
            btn.textContent = originalText;
        } else {
            alert(`‚ùå Fehler: ${data.error || 'Unbekannter Fehler'}`);
            btn.disabled = false;
            btn.textContent = originalText;
        }
    } catch (err) {
        alert(`‚ùå Training fehlgeschlagen: ${err}`);
        btn.disabled = false;
        btn.textContent = originalText;
    }
}

async function triggerBatchReprocess() {
    const btn = document.getElementById('batchReprocessBtn');
    const originalText = btn.textContent;
    
    // Warnung und Best√§tigung
    if (!confirm(
        '‚ö†Ô∏è Alle Emails neu embedden?\n\n' +
        'Dies wird ALLE Emails mit dem aktuellen EMBEDDING Model neu verarbeiten.\n\n' +
        'Grund: Semantic Search funktioniert nur, wenn alle Emails das gleiche Embedding-Model verwenden!\n\n' +
        'Dies kann je nach Anzahl einige Minuten dauern.\n\n' +
        'Fortfahren?'
    )) {
        return;
    }
    
    btn.disabled = true;
    btn.textContent = '‚è≥ Job wird gestartet...';
    
    try {
        const response = await fetch('/api/batch-reprocess-embeddings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
            }
        });
        
        const data = await response.json();
        
        if (data.status === 'queued' && data.job_id) {
            // Job gestartet ‚Üí Progress-Modal
            alert('üïí Batch-Reprocess l√§uft im Hintergrund.');
            pollBatchReprocessStatus(data.job_id, btn, originalText);
        } else if (data.success) {
            alert(`‚úÖ ${data.message}`);
            btn.disabled = false;
            btn.textContent = originalText;
        } else {
            alert(`‚ùå Fehler: ${data.error || 'Unbekannter Fehler'}`);
            btn.disabled = false;
            btn.textContent = originalText;
        }
    } catch (err) {
        alert(`‚ùå Batch-Reprocessing fehlgeschlagen: ${err}`);
        btn.disabled = false;
        btn.textContent = originalText;
    }
}

function pollBatchReprocessStatus(jobId, btn, originalLabel, attempt = 0, startTime = Date.now(), emailStartTime = null, lastEmailIndex = null) {
    // Job-Ownership Management: Bei erstem Aufruf √ºbernimmt dieser Job das Modal
    if (attempt === 0) {
        if (currentActiveJobId && currentActiveJobId !== jobId) {
            console.log(`‚ö†Ô∏è Batch-Job ${jobId} √ºbernimmt Modal von ${currentActiveJobId}`);
        }
        currentActiveJobId = jobId;
    }
    
    // Ignoriere Updates von nicht-aktiven Jobs
    if (currentActiveJobId !== jobId) {
        console.log(`üõë Batch-Poll ignoriert: Job ${jobId} nicht aktiv (aktiv: ${currentActiveJobId})`);
        return;
    }
    
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const modal = getAnalysisModal();
    if (attempt === 0) modal.show();
    
    const perEmailTimeout = 600;  // 10 Minuten pro E-Mail
    
    fetch(`/jobs/${jobId}`, {cache: 'no-store'})
        .then(r => {
            if (r.status === 404) throw new Error('Job nicht gefunden');
            if (r.status === 429) {
                console.warn('Rate-Limit erreicht, warte 30s...');
                setTimeout(() => pollBatchReprocessStatus(jobId, btn, originalLabel, attempt + 1, startTime, emailStartTime, lastEmailIndex), 30000);
                return null;
            }
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            return r.json();
        })
        .then(status => {
            if (status === null) return;  // Rate-limit retry
            
            const currentIdx = status.current_email_index || 0;
            
            // Wenn neue E-Mail begonnen wird, Timer zur√ºcksetzen
            if (lastEmailIndex !== null && currentIdx > lastEmailIndex) {
                emailStartTime = Date.now();
            }
            if (emailStartTime === null) {
                emailStartTime = Date.now();
            }
            
            const emailElapsed = Math.floor((Date.now() - emailStartTime) / 1000);
            const emailRemaining = perEmailTimeout - emailElapsed;
            
            document.getElementById('elapsedTime').textContent = formatTime(emailElapsed);
            document.getElementById('remainingTime').textContent = emailRemaining > 0 ? '~' + formatTime(emailRemaining) : 'abgelaufen!';
            
            if (status.state === 'done') {
                const processed = status.processed ?? 0;
                const failed = status.failed ?? 0;
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressPercent').textContent = '100%';
                document.getElementById('emailCount').textContent = `${status.total_emails || '?'}/${status.total_emails || '?'}`;
                document.getElementById('progressText').textContent = `‚úÖ Batch-Reprocess: Fertig!`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusTitle').textContent = '‚úÖ Batch-Reprocess abgeschlossen';
                document.getElementById('statusDetails').textContent = `${processed} erfolgreich / ${failed} fehlgeschlagen.`;
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel || 'üîÑ Alle Emails neu embedden';
                    }
                });
                return;
            }
            if (status.state === 'error') {
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressBar').classList.add('bg-danger');
                document.getElementById('progressText').textContent = `‚ùå Batch-Reprocess: ${status.message || 'Fehlgeschlagen.'}`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusMessage').querySelector('.alert').className = 'alert alert-danger mb-0';
                document.getElementById('statusTitle').textContent = '‚ùå Fehler beim Batch-Reprocess';
                document.getElementById('statusDetails').textContent = status.message || 'Fehlgeschlagen.';
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel;
                    }
                });
                return;
            }
            
            const totalEmails = status.total_emails || 1;
            const currentSubject = status.current_subject || '';
            
            document.getElementById('emailCount').textContent = `${currentIdx}/${totalEmails}`;
            
            if (emailRemaining <= 0) {
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('progressBar').classList.add('bg-danger');
                document.getElementById('progressText').textContent = `‚ùå Timeout √ºberschritten.`;
                document.getElementById('statusMessage').style.display = 'block';
                document.getElementById('statusMessage').querySelector('.alert').className = 'alert alert-warning mb-0';
                document.getElementById('statusTitle').textContent = '‚è±Ô∏è Timeout √ºberschritten';
                document.getElementById('statusDetails').textContent = `Die Verarbeitung konnte nicht abgeschlossen werden.`;
                document.getElementById('closeAnalysisBtn').style.display = 'block';
                document.getElementById('closeAnalysisBtn').addEventListener('click', function() {
                    modal.hide();
                    currentActiveJobId = null;  // Reset job tracking
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalLabel;
                    }
                });
                return;
            }
            
            const progress = Math.min(95, (currentIdx / totalEmails) * 100);
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('progressPercent').textContent = Math.floor(progress) + '%';
            const subjectDisplay = currentSubject ? ` - ${currentSubject}` : '';
            document.getElementById('progressText').textContent = `Batch-Reprocess: Email ${currentIdx}/${totalEmails}${subjectDisplay}`;
            
            setTimeout(() => pollBatchReprocessStatus(jobId, btn, originalLabel, attempt + 1, startTime, emailStartTime, currentIdx), 2000);
        })
        .catch(err => {
            modal.hide();
            currentActiveJobId = null;  // Reset job tracking bei Error
            alert(`‚ùå Status-Check fehlgeschlagen: ${err}`);
            if (btn) {
                btn.disabled = false;
                btn.textContent = originalLabel || 'üîÑ Alle Emails neu embedden';
            }
        });
}

document.addEventListener('DOMContentLoaded', () => {
    // Security: Parse JSON safely to prevent XSS via provider/model names
    try {
        window.savedAIValues = {{ {
            'Embedding': {'provider': ai_selected_provider_embedding|default('ollama'), 'model': ai_selected_model_embedding|default('all-minilm:22m')},
            'Base': {'provider': ai_selected_provider_base, 'model': ai_selected_model_base},
            'Optimize': {'provider': ai_selected_provider_optimize, 'model': ai_selected_model_optimize}
        }|tojson|safe }};
    } catch(e) {
        console.error('Failed to parse AI values:', e);
        window.savedAIValues = {
            Embedding: {provider: 'ollama', model: 'all-minilm:22m'},
            Base: {provider: 'ollama', model: 'llama3.2:1b'},
            Optimize: {provider: 'ollama', model: 'llama3.2:3b'}
        };
    }
    initializeProviders();
    loadTrainingStats();
    
    // CSP-compliant event listeners (no inline handlers) - 3 Settings!
    const providerEmbeddingSelect = document.getElementById('aiProviderSelectEmbedding');
    const providerBaseSelect = document.getElementById('aiProviderSelectBase');
    const providerOptimizeSelect = document.getElementById('aiProviderSelectOptimize');
    const retrainBtn = document.getElementById('retrainBtn');
    const batchReprocessBtn = document.getElementById('batchReprocessBtn');
    const regenerateForm = document.getElementById('regenerateRecoveryForm');
    
    if (providerEmbeddingSelect) {
        providerEmbeddingSelect.addEventListener('change', () => updateModels('Embedding'));
    }
    if (providerBaseSelect) {
        providerBaseSelect.addEventListener('change', () => updateModels('Base'));
    }
    if (providerOptimizeSelect) {
        providerOptimizeSelect.addEventListener('change', () => updateModels('Optimize'));
    }
    if (retrainBtn) {
        retrainBtn.addEventListener('click', triggerRetraining);
    }
    if (batchReprocessBtn) {
        batchReprocessBtn.addEventListener('click', triggerBatchReprocess);
    }
    if (regenerateForm) {
        regenerateForm.addEventListener('submit', (e) => {
            if (!confirmRegenerate()) {
                e.preventDefault();
            }
        });
    }
    
    // Event delegation for dynamic buttons (fetchMails, purgeMails, delete, syncFlags)
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('fetch-mails-btn')) {
            const accountId = parseInt(e.target.dataset.accountId);
            const accountName = e.target.dataset.accountName;
            fetchMails(e, accountId, accountName);
        }
        if (e.target.classList.contains('purge-mails-btn')) {
            const accountId = parseInt(e.target.dataset.accountId);
            const accountName = e.target.dataset.accountName;
            purgeMails(e, accountId, accountName);
        }
        if (e.target.classList.contains('quick-count-btn')) {
            const accountId = parseInt(e.target.dataset.accountId);
            const accountName = e.target.dataset.accountName;
            quickCount(e, accountId, accountName);
        }
        
        // Sync-Buttons: closest() weil Klick auf <small> child m√∂glich
        const syncFlagsBtn = e.target.closest('.sync-flags-btn');
        if (syncFlagsBtn) {
            e.preventDefault();
            const accountId = parseInt(syncFlagsBtn.dataset.accountId);
            const accountName = syncFlagsBtn.dataset.accountName;
            syncFlags({target: syncFlagsBtn}, accountId, accountName);
        }
        
        const syncServerBtn = e.target.closest('.sync-server-btn');
        if (syncServerBtn) {
            e.preventDefault();
            const accountId = parseInt(syncServerBtn.dataset.accountId);
            const accountName = syncServerBtn.dataset.accountName;
            syncServer({target: syncServerBtn}, accountId, accountName);
        }
    });
    
    // Delete form confirmation
    document.querySelectorAll('.delete-account-form').forEach(form => {
        form.addEventListener('submit', (e) => {
            if (!confirm('Wirklich l√∂schen?')) {
                e.preventDefault();
            }
        });
    });
    
    // Load folders button
    const loadFoldersBtn = document.getElementById('loadFoldersBtn');
    const folderAccountSelect = document.getElementById('folderAccountSelect');
    
    if (loadFoldersBtn) {
        loadFoldersBtn.addEventListener('click', loadFoldersForFilter);
    }
    
    // Phase 13C Part 6: Account-Select Listener - l√§dt Filter automatisch
    if (folderAccountSelect) {
        folderAccountSelect.addEventListener('change', async () => {
            const accountId = folderAccountSelect.value;
            if (accountId) {
                // Update hidden field im Form
                document.getElementById('formAccountId').value = accountId;
                
                // Lade Filter des gew√§hlten Accounts
                try {
                    const response = await fetch(`/account/${accountId}/fetch-filters`);
                    const filterData = await response.json();
                    
                    // Setze Filter-Felder
                    const sinceDateInput = document.getElementById('sinceDate');
                    const unseenCheckbox = document.getElementById('unseenOnly');
                    
                    if (sinceDateInput) sinceDateInput.value = filterData.since_date || '';
                    if (unseenCheckbox) unseenCheckbox.checked = filterData.unseen_only || false;
                    
                    // Speichere Filter-Daten f√ºr sp√§ter (beim Ordner-Laden)
                    window.accountFilterData = filterData;
                    
                    console.log('‚úÖ Filter geladen f√ºr Account', filterData.account_name);
                    
                    // Phase 13C Part 6+: Ordner sofort laden (mit aktuellen Filtern!)
                    // Debounce: Warte kurz, falls User schnell zwischen Accounts wechselt
                    if (loadFoldersDebounceTimer) {
                        clearTimeout(loadFoldersDebounceTimer);
                    }
                    loadFoldersDebounceTimer = setTimeout(() => {
                        loadFoldersForFilter();
                        loadFoldersDebounceTimer = null;
                    }, 200);
                    
                } catch (e) {
                    console.warn('Filter-Laden fehlgeschlagen:', e);
                }
            } else {
                // Reset bei keiner Auswahl
                document.getElementById('formAccountId').value = '';
            }
        });
    }
    
    // Phase 13C Part 6: Form-Submit Handling - State beibehalten
    const fetchConfigForm = document.getElementById('fetchConfigForm');
    if (fetchConfigForm) {
        fetchConfigForm.addEventListener('submit', (e) => {
            const accountId = document.getElementById('formAccountId').value;
            if (!accountId) {
                e.preventDefault();
                alert('Bitte zuerst einen Account ausw√§hlen');
                return false;
            }
            
            // Speichere Account-ID im localStorage f√ºr Reload
            localStorage.setItem('lastSelectedAccountId', accountId);
        });
    }
    
    // Nach Page-Load: Restore Account-Auswahl
    window.addEventListener('load', () => {
        const lastAccountId = localStorage.getItem('lastSelectedAccountId');
        const folderAccountSelect = document.getElementById('folderAccountSelect');
        
        if (lastAccountId && folderAccountSelect) {
            folderAccountSelect.value = lastAccountId;
            // Trigger change event um Filter zu laden
            folderAccountSelect.dispatchEvent(new Event('change'));
            // Lade auch die Ordner automatisch
            setTimeout(() => {
                document.getElementById('loadFoldersBtn')?.click();
            }, 500);
        }
    });
    
    // Phase 13C Part 5: Event Listener f√ºr Fetch-Vorschau Updates
    const mailsPerFolderInput = document.querySelector('input[name="mails_per_folder"]');
    const maxTotalInput = document.querySelector('input[name="max_total_mails"]');
    const unseenCheckbox = document.getElementById('unseenOnly');
    const sinceDateInput = document.getElementById('sinceDate');
    
    // Speichere letzte Daten global f√ºr Updates
    window.lastFetchData = null;

    // Alle ausw√§hlen/abw√§hlen Funktionen (global f√ºr CSP-Kompatibilit√§t)
    window.toggleAllIncludes = function(selectAll) {
        const checkboxes = document.querySelectorAll('input[name="include_folders"]');
        console.log(`Toggle all includes: ${selectAll}, found ${checkboxes.length} checkboxes`);
        checkboxes.forEach(cb => {
            if (cb.checked !== selectAll) {
                cb.checked = selectAll;
            }
        });
        // Update preview nach Massen√§nderung
        if (window.lastFetchData) {
            updateFetchPreview(window.lastFetchData);
        }
    };

    window.toggleAllExcludes = function(selectAll) {
        const checkboxes = document.querySelectorAll('input[name="exclude_folders"]');
        console.log(`Toggle all excludes: ${selectAll}, found ${checkboxes.length} checkboxes`);
        checkboxes.forEach(cb => {
            if (cb.checked !== selectAll) {
                cb.checked = selectAll;
            }
        });
        // Update preview nach Massen√§nderung
        if (window.lastFetchData) {
            updateFetchPreview(window.lastFetchData);
        }
    };

    // Binde Event Listener an die Buttons (wird nach dem Laden aufgerufen)
    window.bindToggleButtons = function() {
        // Include Buttons
        const selectAllIncBtn = document.getElementById('selectAllIncludes');
        const selectNoneIncBtn = document.getElementById('selectNoneIncludes');
        if (selectAllIncBtn) {
            selectAllIncBtn.onclick = () => window.toggleAllIncludes(true);
            console.log('‚úÖ Bound selectAllIncludes button');
        }
        if (selectNoneIncBtn) {
            selectNoneIncBtn.onclick = () => window.toggleAllIncludes(false);
            console.log('‚úÖ Bound selectNoneIncludes button');
        }

        // Exclude Buttons
        const selectAllExcBtn = document.getElementById('selectAllExcludes');
        const selectNoneExcBtn = document.getElementById('selectNoneExcludes');
        if (selectAllExcBtn) {
            selectAllExcBtn.onclick = () => window.toggleAllExcludes(true);
            console.log('‚úÖ Bound selectAllExcludes button');
        }
        if (selectNoneExcBtn) {
            selectNoneExcBtn.onclick = () => window.toggleAllExcludes(false);
            console.log('‚úÖ Bound selectNoneExcludes button');
        }
    };
    
    [mailsPerFolderInput, maxTotalInput, unseenCheckbox, sinceDateInput].forEach(el => {
        if (el) {
            el.addEventListener('change', () => {
                // Phase 13C Part 6+: Bei sinceDate/unseenOnly √Ñnderung: Ordner NEU laden (wegen since_count)
                const accountSelect = document.getElementById('folderAccountSelect');
                const accountId = accountSelect ? accountSelect.value : null;
                
                if ((el === sinceDateInput || el === unseenCheckbox) && accountId) {
                    // üîß FIX: Reset Request-Tracking und Account-ID damit Ordner WIRKLICH neu geladen werden
                    currentMailCountRequest = null;
                    lastLoadedAccountId = null;
                    console.log('üîÑ Toggle ge√§ndert - lade Ordner neu f√ºr Account', accountId);
                    // Ordner neu laden mit neuen Filtern
                    loadFoldersForFilter();
                } else if (window.lastFetchData) {
                    // Nur Vorschau updaten (mails_per_folder, max_total)
                    updateFetchPreview(window.lastFetchData);
                }
            });
        }
    });
});

// Phase 13C Part 5: Ordner f√ºr Filter laden
// Tracking f√ºr laufende Requests
let currentMailCountRequest = null;
let loadFoldersDebounceTimer = null;
let lastLoadedAccountId = null;

async function loadFoldersForFilter() {
    const accountId = document.getElementById('folderAccountSelect').value;
    if (!accountId) {
        alert('Bitte zuerst einen Account ausw√§hlen');
        return;
    }
    
    // Phase 13C Fix: Pr√ºfe ob Request AKTUELL l√§uft (nicht abgeschlossen)
    // AbortController.signal.aborted zeigt an, ob der Request noch aktiv ist
    const isRequestRunning = currentMailCountRequest && !currentMailCountRequest.signal.aborted;
    
    // Verhindere doppelte Requests f√ºr denselben Account NUR wenn Request noch l√§uft
    if (lastLoadedAccountId === accountId && isRequestRunning) {
        console.log('‚è≠Ô∏è Request f√ºr Account', accountId, 'l√§uft bereits - √ºberspringe');
        return;
    }
    
    // Breche vorherigen Request ab wenn Account gewechselt wurde
    if (isRequestRunning && lastLoadedAccountId !== accountId) {
        console.log('‚ùå Breche alten Request ab (Account-Wechsel)');
        currentMailCountRequest.abort();
        currentMailCountRequest = null;
    }
    
    // Reset: Erlaube neuen Request f√ºr gleichen Account (z.B. nach Filter-√Ñnderung)
    currentMailCountRequest = null;
    lastLoadedAccountId = accountId;
    
    const includeContainer = document.getElementById('includeFoldersContainer');
    const excludeContainer = document.getElementById('excludeFoldersContainer');
    
    includeContainer.innerHTML = '<small class="text-muted">Lade Ordner...</small>';
    excludeContainer.innerHTML = '<small class="text-muted">Lade Ordner...</small>';
    
    try {
        // Phase 13C Part 6+: since_date + unseen_only Parameter √ºbergeben f√ºr exakte Sch√§tzung
        const sinceDateInput = document.getElementById('sinceDate');
        const sinceDate = sinceDateInput ? sinceDateInput.value : '';
        const unseenOnly = document.getElementById('unseenOnly')?.checked || false;
        
        // üéØ Lade gespeicherte include_folders vom Account
        let includeFolders = [];
        if (window.accountFilterData && window.accountFilterData.include_folders) {
            includeFolders = window.accountFilterData.include_folders;
        }
        // ‚ö†Ô∏è WICHTIG: Wenn keine include_folders gespeichert, nehme ALLE (Default-Verhalten)
        // Das passiert beim ersten Laden eines Accounts ohne gespeicherte Filter
        const sendIncludeFolders = includeFolders.length > 0;
        
        let url = `/account/${accountId}/mail-count`;
        const params = [];
        if (sinceDate) {
            params.push(`since_date=${encodeURIComponent(sinceDate)}`);
        }
        if (unseenOnly) {
            params.push(`unseen_only=true`);
        }
        // üéØ Schicke include_folders mit (nur diese werden f√ºr SINCE gez√§hlt!)
        if (sendIncludeFolders) {
            params.push(`include_folders=${encodeURIComponent(JSON.stringify(includeFolders))}`);
            console.log(`üéØ SINCE-Count nur f√ºr ${includeFolders.length} ausgew√§hlte Ordner`);
        } else {
            console.log('üìÇ Keine Filter gespeichert - zeige nur STATUS (ohne SINCE)');
        }
        if (params.length > 0) {
            url += '?' + params.join('&');
        }
        
        console.log('üîÑ Fetching:', url);
        
        // AbortController f√ºr abbruchbare Requests
        const abortController = new AbortController();
        currentMailCountRequest = abortController;
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
            credentials: 'same-origin',
            signal: abortController.signal
        });
        
        console.log('üì• Response status:', response.status);
        
        // Pr√ºfe HTTP-Status
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Response error:', errorText);
            throw new Error(`Server-Fehler (${response.status}): ${errorText.substring(0, 100)}`);
        }
        
        const data = await response.json();
        
        console.log('üìä Received data:', data);
        console.log('üìÅ Folders:', data.folders);
        
        // Debug: Zeige ob since_count vorhanden ist
        if (data.folders && Object.keys(data.folders).length > 0) {
            const firstFolder = Object.keys(data.folders)[0];
            console.log('üîç Debug first folder:', firstFolder, data.folders[firstFolder]);
        }
        
        // Pr√ºfe ob Ordner vorhanden sind
        if (!data.folders || Object.keys(data.folders).length === 0) {
            throw new Error('Keine Ordner gefunden. M√∂glicherweise Authentifizierungsproblem.');
        }
        
        const folders = Object.keys(data.folders).sort();
        console.log('‚úÖ Folder names:', folders);
        
        // Speichere Daten global f√ºr sp√§tere Updates
        window.lastFetchData = data;
        currentMailCountRequest = null;
        
        // Phase 13C Part 6: Gespeicherte Auswahl vom Account laden
        let savedInclude = [];
        let savedExclude = [];
        
        if (window.accountFilterData) {
            savedInclude = window.accountFilterData.include_folders || [];
            savedExclude = window.accountFilterData.exclude_folders || [];
            console.log('üìã Filter vom Account:', { savedInclude, savedExclude });
        }
        
        // Include Checkboxen mit hierarchischer Darstellung
        includeContainer.innerHTML = ''; // Clear first
        const includeList = document.createElement('div');
        includeList.className = 'folder-list';
        
        folders.forEach(folderName => {
            const checked = savedInclude.length === 0 || savedInclude.includes(folderName);
            const safeFolderId = String(folderName).replace(/[^a-zA-Z0-9]/g, '_');
            const folderData = data.folders[folderName] || {};
            const mailCount = folderData.total || 0;
            const unseenCount = folderData.unseen || 0;
            const sinceCount = folderData.since; // kann null/undefined sein
            
            // Berechne Einr√ºckung basierend auf Slashes
            const depth = (folderName.match(/\//g) || []).length;
            const indent = depth * 20; // 20px pro Level
            
            const formCheck = document.createElement('div');
            formCheck.className = 'form-check mb-1';
            formCheck.style.paddingLeft = (indent + 25) + 'px'; // Base padding + indent
            
            const checkbox = document.createElement('input');
            checkbox.className = 'form-check-input';
            checkbox.type = 'checkbox';
            checkbox.name = 'include_folders';
            checkbox.value = folderName;
            checkbox.id = 'inc_' + safeFolderId;
            checkbox.checked = checked;
            
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = 'inc_' + safeFolderId;
            label.style.fontSize = '0.9rem';
            label.style.wordBreak = 'break-word';
            
            // Zeige nur den letzten Teil des Pfads, wenn tief verschachtelt
            const displayName = depth > 0 ? '‚îî ' + folderName.split('/').pop() : folderName;
            label.textContent = displayName + ' ';
            label.title = folderName; // Tooltip mit vollem Pfad
            
            const badge = document.createElement('span');
            badge.className = 'badge bg-secondary ms-1';
            badge.style.fontSize = '0.75rem';
            // Zeige SINCE-Count wenn vorhanden, sonst total/unseen
            if (sinceCount !== null && sinceCount !== undefined) {
                badge.className = 'badge bg-primary ms-1'; // Blau f√ºr SINCE-Filtered
                badge.textContent = sinceCount + ' (gefiltert)';
                badge.title = `${sinceCount} Mails seit Filter (${mailCount} total, ${unseenCount} ungelesen)`;
            } else {
                badge.textContent = mailCount + '/' + unseenCount;
                badge.title = `${mailCount} gesamt, ${unseenCount} ungelesen`;
            }
            label.appendChild(badge);
            
            formCheck.appendChild(checkbox);
            formCheck.appendChild(label);
            includeList.appendChild(formCheck);
        });
        
        includeContainer.appendChild(includeList);
        
        const hint = document.createElement('small');
        hint.className = 'text-muted d-block mt-2';
        hint.textContent = 'Keine Auswahl = alle Ordner';
        includeContainer.appendChild(hint);
        
        // Event Listener f√ºr Include Checkboxen
        document.querySelectorAll('input[name="include_folders"]').forEach(cb => {
            cb.addEventListener('change', () => updateFetchPreview(data));
        });
        
        // Exclude Checkboxen mit hierarchischer Darstellung
        excludeContainer.innerHTML = ''; // Clear first
        const excludeList = document.createElement('div');
        excludeList.className = 'folder-list';
        
        folders.forEach(folderName => {
            // Nur gespeicherte Excludes verwenden, KEINE Auto-Selektion mehr
            const checked = savedExclude.includes(folderName);
            const safeFolderId = String(folderName).replace(/[^a-zA-Z0-9]/g, '_');
            const folderData = data.folders[folderName] || {};
            const mailCount = folderData.total || 0;
            const unseenCount = folderData.unseen || 0;
            
            // Berechne Einr√ºckung basierend auf Slashes
            const depth = (folderName.match(/\//g) || []).length;
            const indent = depth * 20; // 20px pro Level
            
            const formCheck = document.createElement('div');
            formCheck.className = 'form-check mb-1';
            formCheck.style.paddingLeft = (indent + 25) + 'px'; // Base padding + indent
            
            const checkbox = document.createElement('input');
            checkbox.className = 'form-check-input';
            checkbox.type = 'checkbox';
            checkbox.name = 'exclude_folders';
            checkbox.value = folderName;
            checkbox.id = 'exc_' + safeFolderId;
            checkbox.checked = checked;
            
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = 'exc_' + safeFolderId;
            label.style.fontSize = '0.9rem';
            label.style.wordBreak = 'break-word';
            
            // Zeige nur den letzten Teil des Pfads, wenn tief verschachtelt
            const displayName = depth > 0 ? '‚îî ' + folderName.split('/').pop() : folderName;
            label.textContent = displayName + ' ';
            label.title = folderName; // Tooltip mit vollem Pfad
            
            const badge = document.createElement('span');
            badge.className = 'badge bg-secondary ms-1';
            badge.style.fontSize = '0.75rem';
            badge.textContent = mailCount + '/' + unseenCount;
            badge.title = `${mailCount} gesamt, ${unseenCount} ungelesen`;
            label.appendChild(badge);
            
            formCheck.appendChild(checkbox);
            formCheck.appendChild(label);
            excludeList.appendChild(formCheck);
        });
        
        excludeContainer.appendChild(excludeList);
        
        // Event Listener f√ºr Exclude Checkboxen
        document.querySelectorAll('input[name="exclude_folders"]').forEach(cb => {
            cb.addEventListener('change', () => updateFetchPreview(data));
        });
        
        // ‚úÖ WICHTIG: Binde Toggle-Buttons NACHDEM die Container erstellt wurden
        if (typeof window.bindToggleButtons === 'function') {
            window.bindToggleButtons();
        } else {
            console.error('‚ùå window.bindToggleButtons is not defined!');
        }
        
        // Trigger initial preview mit kompletten Daten (inkl. summary)
        updateFetchPreview(data);
        
    } catch (error) {
        // Handle AbortError separat (normal bei Account-Wechsel)
        if (error.name === 'AbortError') {
            console.log('üõë Request abgebrochen (normal bei Account-Wechsel)');
            currentMailCountRequest = null;
            return;
        }
        
        console.error('‚ùå Fehler beim Laden der Ordner:', error);
        console.error('Error stack:', error.stack);
        
        let errorMessage = 'Fehler beim Laden der Ordner';
        if (error.message) {
            errorMessage = error.message;
        }
        if (error.name === 'TypeError' && error.message.includes('NetworkError')) {
            errorMessage = 'Netzwerkfehler - Ist der Server erreichbar? Probiere die Seite neu zu laden (F5).';
        }
        
        includeContainer.innerHTML = `<small class="text-danger">${errorMessage}</small>`;
        excludeContainer.innerHTML = `<small class="text-danger">${errorMessage}</small>`;
        currentMailCountRequest = null;
    }
}

// Phase 13C Part 5: Berechne gesch√§tzte Mail-Anzahl mit Filtern
function updateFetchPreview(data) {
    const previewContainer = document.getElementById('fetchPreviewContainer');
    const previewCount = document.getElementById('fetchPreviewCount');
    const previewDetails = document.getElementById('fetchPreviewDetails');
    
    console.log('üî¢ updateFetchPreview called with:', data);
    
    if (!data || !data.folders || Object.keys(data.folders).length === 0) {
        previewContainer.style.display = 'none';
        return;
    }
    
    const folderCounts = data.folders;
    const summary = data.summary || {};
    
    // Hole aktuelle Filter-Einstellungen
    const mailsPerFolderInput = document.querySelector('input[name="mails_per_folder"]');
    const maxTotalInput = document.querySelector('input[name="max_total_mails"]');
    const mailsPerFolder = mailsPerFolderInput ? parseInt(mailsPerFolderInput.value) || 100 : 100;
    const maxTotal = maxTotalInput ? parseInt(maxTotalInput.value) || 0 : 0;
    const unseenOnly = document.getElementById('unseenOnly')?.checked || false;
    const sinceDate = document.getElementById('sinceDate')?.value || '';
    
    console.log('‚öôÔ∏è Settings:', { mailsPerFolder, maxTotal, unseenOnly, sinceDate });
    
    // Welche Ordner werden gefetcht?
    const includeCheckboxes = document.querySelectorAll('input[name="include_folders"]:checked');
    const excludeCheckboxes = document.querySelectorAll('input[name="exclude_folders"]:checked');
    
    let includeFolders = Array.from(includeCheckboxes).map(cb => cb.value);
    let excludeFolders = Array.from(excludeCheckboxes).map(cb => cb.value);
    
    console.log('üìÅ Folders:', { includeFolders, excludeFolders });
    
    // Berechne Summe UND sammle ALLE Ordner-Infos
    let totalEstimate = 0;
    let includedFolderCount = 0;
    let allFolderDetails = [];
    
    Object.entries(folderCounts).forEach(([folderName, folderData]) => {
        const totalCount = (folderData && folderData.total) ? parseInt(folderData.total) : 0;
        const unseenCount = (folderData && folderData.unseen) ? parseInt(folderData.unseen) : 0;
        const sinceCount = (folderData && folderData.since !== null && folderData.since !== undefined) ? parseInt(folderData.since) : null;
        
        // Pr√ºfe ob dieser Ordner durch Filter kommt
        const isIncluded = (includeFolders.length === 0 || includeFolders.includes(folderName)) && !excludeFolders.includes(folderName);
        
        if (isIncluded) {
            // Wenn UNSEEN-Only, nutze unseen count statt total
            let baseCount = unseenOnly ? unseenCount : totalCount;
            
            // Phase 13C Part 6+: Wenn sinceDate gesetzt UND Server hat since_count geliefert ‚Üí nutze das!
            if (sinceDate && sinceCount !== null) {
                baseCount = sinceCount;
            } else if (sinceDate && sinceCount === null) {
                // Fallback: 50% Sch√§tzung (Server konnte SINCE nicht ermitteln)
                baseCount = Math.floor(baseCount * 0.5);
            }
            
            let folderEstimate = Math.min(baseCount, mailsPerFolder);
            
            totalEstimate += folderEstimate;
            includedFolderCount++;
        }
        
        // Sammle ALLE Ordner f√ºr die Anzeige (auch die gefilterten)
        allFolderDetails.push({
            name: String(folderName),
            total: totalCount,
            unseen: unseenCount,
            included: isIncluded
        });
    });
    
    console.log('üìä Estimate:', { totalEstimate, includedFolderCount, allFolderDetails });
    
    // Max Total Limit anwenden
    if (maxTotal > 0 && totalEstimate > maxTotal) {
        totalEstimate = maxTotal;
    }
    
    // Anzeigen
    if (!previewCount || !previewDetails || !previewContainer) {
        console.warn('‚ö†Ô∏è Preview elements not found');
        return;
    }
    
    previewCount.textContent = totalEstimate || 0;
    
    // Details mit HTML-Struktur f√ºr bessere Lesbarkeit
    let detailsHtml = '<div style="font-size: 0.9em;">';
    
    // Filter-Info direkt nach der Zahl anzeigen (c)
    let filterInfoParts = [];
    if (unseenOnly) filterInfoParts.push('nur ungelesen');
    if (sinceDate) {
        // Datum in dd.mm.yyyy formatieren
        const parts = sinceDate.split('-');
        if (parts.length === 3) {
            filterInfoParts.push(`ab ${parts[2]}.${parts[1]}.${parts[0]}`);
        } else {
            filterInfoParts.push(`ab ${sinceDate}`);
        }
    }
    if (maxTotal > 0) filterInfoParts.push(`max ${maxTotal}`);
    
    if (filterInfoParts.length > 0) {
        // Zeige Filter-Info neben der Badge
        const filterSpan = document.createElement('span');
        filterSpan.className = 'text-muted ms-2';
        filterSpan.textContent = `(${filterInfoParts.join(', ')})`;
        previewCount.parentElement.appendChild(filterSpan);
    }
    
    // Remote (Server): NUR gefilterte Ordner anzeigen (a - ausblenden statt durchstreichen)
    const includedFolders = allFolderDetails.filter(fd => fd.included);
    if (includedFolders.length > 0) {
        detailsHtml += '<strong>Remote (Server):</strong><ul style="margin: 5px 0; padding-left: 20px;">';
        includedFolders.forEach(fd => {
            detailsHtml += `<li>${fd.name}: <strong>${fd.total}</strong> Mails (<strong>${fd.unseen}</strong> ungelesen)</li>`;
        });
        detailsHtml += '</ul>';
    }
    
    // Summary-Infos mit gefiltertem Delta (b)
    detailsHtml += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ccc;">`;
    detailsHtml += `<strong>Gesamt Remote:</strong> ${summary.total_remote || 0} Mails<br>`;
    detailsHtml += `<strong>Ungelesen:</strong> ${summary.total_unseen || 0}<br>`;
    detailsHtml += `<strong>Lokal in DB:</strong> ${summary.total_local || 0}<br>`;
    
    // Delta: Gefiltert vs. Lokal (nicht Total vs. Lokal)
    const filteredDelta = Math.max(0, totalEstimate - (summary.total_local || 0));
    const deltaColor = filteredDelta > 0 ? '#856404' : '#155724';
    detailsHtml += `<strong style="color: ${deltaColor};">Delta:</strong> ${filteredDelta} Mails fehlen lokal`;
    detailsHtml += '</div>';
    
    detailsHtml += '</div>';
    
    previewDetails.innerHTML = detailsHtml;
    previewContainer.style.display = 'block';
}

// ============================================================================
// Phase X: Trusted Senders + UrgencyBooster JavaScript Functions (Account-Aware)
// ============================================================================

// Load and display trusted senders list (Account-Aware)
async function loadTrustedSendersList() {
    try {
        const accountSelector = document.getElementById('whitelistAccountSelector');
        if (!accountSelector) {
            console.warn('whitelistAccountSelector not found - skipping trusted senders load');
            return;
        }
        const selectedAccountId = accountSelector.value;
        
        // Build URL with account_id if selected
        const url = selectedAccountId ? 
            `/api/trusted-senders?account_id=${selectedAccountId}` : 
            '/api/trusted-senders';
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {'Content-Type': 'application/json'}
        });
        const data = await response.json();
        
        if (!data.success) {
            console.error('Failed to load trusted senders:', data.error);
            return;
        }
        
        const list = document.getElementById('trustedSendersList');
        if (!list) {
            console.warn('trustedSendersList element not found');
            return;
        }
        if (data.senders.length === 0) {
            list.innerHTML = '<div class="text-muted text-center py-4">Noch keine vertrauensw√ºrdigen Absender</div>';
            return;
        }
        
        list.innerHTML = data.senders.map(sender => `
            <div class="list-group-item bg-dark text-light d-flex justify-content-between align-items-start gap-2 py-3">
                <div style="flex-grow: 1;">
                    <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                        <select class="form-select form-select-sm" style="width: auto; padding: 0.25rem 0.5rem; font-size: 0.85rem;" 
                                onchange="editTrustedSenderType(${sender.id}, this.value)">
                            <option value="exact" ${sender.pattern_type === 'exact' ? 'selected' : ''}>üîí Exakt</option>
                            <option value="email_domain" ${sender.pattern_type === 'email_domain' ? 'selected' : ''}>üë• Wildcard</option>
                            <option value="domain" ${sender.pattern_type === 'domain' ? 'selected' : ''}>üè¢ Domain + Subdomains</option>
                        </select>
                        ${sender.account_id ? `<small class="badge bg-warning text-dark">üìß Account ${sender.account_id}</small>` : 
                          `<small class="badge bg-secondary">üåç Global</small>`}
                    </div>
                    <div class="font-monospace small text-light">${sender.sender_pattern}</div>
                    ${sender.label ? `<small class="text-muted d-block">üìù ${sender.label}</small>` : ''}
                    <small class="text-muted d-block mt-1">
                        üìß ${sender.email_count} Mails
                        ${sender.last_seen_at ? ` ‚Ä¢ Zuletzt: ${new Date(sender.last_seen_at).toLocaleDateString('de-DE')}` : ''}
                    </small>
                </div>
                <div class="d-flex gap-1 flex-wrap">
                    <button type="button" class="btn btn-sm btn-outline-light" 
                            onclick="toggleUrgencyBooster(${sender.id}, ${!sender.use_urgency_booster})"
                            title="UrgencyBooster ${sender.use_urgency_booster ? 'deaktivieren' : 'aktivieren'}">
                        ${sender.use_urgency_booster ? '‚ö°' : '‚≠ï'}
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-danger" 
                            onclick="deleteTrustedSender(${sender.id})">
                        üóëÔ∏è
                    </button>
                </div>
            </div>
        `).join('');
    } catch (error) {
        console.error('Error loading trusted senders:', error);
        document.getElementById('trustedSendersList').innerHTML = 
            `<div class="alert alert-danger small mb-0">Fehler beim Laden: ${error.message}</div>`;
    }
}

// Filter senders when account selector changes
document.addEventListener('DOMContentLoaded', function() {
    const accountSelector = document.getElementById('whitelistAccountSelector');
    if (accountSelector) {
        accountSelector.addEventListener('change', loadTrustedSendersList);
        // Load initial trusted senders list
        loadTrustedSendersList();
    }
});

// Toggle UrgencyBooster for a sender
async function toggleUrgencyBooster(senderId, newValue) {
    try {
        const accountSelector = document.getElementById('whitelistAccountSelector');
        const accountId = accountSelector.value;
        
        const url = accountId ? 
            `/api/trusted-senders/${senderId}?account_id=${accountId}` : 
            `/api/trusted-senders/${senderId}`;
        
        const response = await fetch(url, {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({use_urgency_booster: newValue})
        });
        
        const data = await response.json();
        if (data.success) {
            loadTrustedSendersList();
        } else {
            alert('Fehler: ' + data.error);
        }
    } catch (error) {
        console.error('Error toggling urgency booster:', error);
        alert('Fehler beim Aktualisieren');
    }
}

// Edit trusted sender type
async function editTrustedSenderType(senderId, newType) {
    try {
        const accountSelector = document.getElementById('whitelistAccountSelector');
        const accountId = accountSelector ? accountSelector.value : '';
        
        const url = accountId ? 
            `/api/trusted-senders/${senderId}?account_id=${accountId}` : 
            `/api/trusted-senders/${senderId}`;
        
        const response = await fetch(url, {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({pattern_type: newType})
        });
        
        const data = await response.json();
        if (data.success) {
            loadTrustedSendersList();
        } else {
            alert('Fehler: ' + data.error);
            loadTrustedSendersList(); // Refresh to revert dropdown
        }
    } catch (error) {
        console.error('Error updating sender type:', error);
        alert('Fehler beim Aktualisieren');
        loadTrustedSendersList(); // Refresh to revert dropdown
    }
}

// Delete a trusted sender
async function deleteTrustedSender(senderId) {
    if (!confirm('Diesen Sender wirklich l√∂schen?')) return;
    
    try {
        const accountSelector = document.getElementById('whitelistAccountSelector');
        const accountId = accountSelector.value;
        
        const url = accountId ? 
            `/api/trusted-senders/${senderId}?account_id=${accountId}` : 
            `/api/trusted-senders/${senderId}`;
        
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {'Content-Type': 'application/json'}
        });
        
        const data = await response.json();
        if (data.success) {
            loadTrustedSendersList();
        } else {
            alert('Fehler: ' + data.error);
        }
    } catch (error) {
        console.error('Error deleting trusted sender:', error);
        alert('Fehler beim L√∂schen');
    }
}

// Add new trusted sender (Account-Aware)
async function addTrustedSender() {
    const patternInput = document.getElementById('trustedSenderPattern');
    const typeSelect = document.getElementById('trustedSenderType');
    const labelInput = document.getElementById('trustedSenderLabel');
    const boosterCheckbox = document.getElementById('trustedSenderUseBooster');
    const accountSelect = document.getElementById('trustedSenderAccountId');
    
    // Validation
    if (!patternInput || !typeSelect || !boosterCheckbox) {
        console.error('Required form elements not found');
        alert('Fehler: Formularelemente nicht gefunden');
        return;
    }
    
    const pattern = patternInput.value.trim();
    const type = typeSelect.value;
    const label = labelInput ? labelInput.value.trim() : '';
    const useBooster = boosterCheckbox.checked;
    const accountId = accountSelect ? accountSelect.value : '';
    
    if (!pattern) {
        alert('‚ö†Ô∏è Bitte Absender-Muster eingeben');
        patternInput.focus();
        return;
    }
    
    try {
        const addBtn = document.getElementById('addTrustedSenderBtn');
        if (addBtn) addBtn.disabled = true;
        
        const response = await fetch('/api/trusted-senders', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                sender_pattern: pattern,
                pattern_type: type,
                label: label || null,
                use_urgency_booster: useBooster,
                account_id: accountId ? parseInt(accountId) : null
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.success) {
            alert(`‚ùå Fehler: ${data.error}`);
            return;
        }
        
        // Reset form
        patternInput.value = '';
        if (labelInput) labelInput.value = '';
        typeSelect.value = 'exact';
        boosterCheckbox.checked = true;
        if (accountSelect) accountSelect.value = '';
        
        alert('‚úÖ Absender hinzugef√ºgt!');
        loadTrustedSendersList();
    } catch (error) {
        console.error('Error adding trusted sender:', error);
        alert(`‚ùå Fehler: ${error.message}`);
    } finally {
        const addBtn = document.getElementById('addTrustedSenderBtn');
        if (addBtn) addBtn.disabled = false;
    }
}

// Load urgency booster setting
async function loadUrgencyBoosterStatus() {
    try {
        const response = await fetch('/api/settings/urgency-booster', {
            method: 'GET',
            headers: {'Content-Type': 'application/json'}
        });
        const data = await response.json();
        
        if (data.success) {
            const toggleElement = document.getElementById('urgencyBoosterToggle');
            if (toggleElement) {
                toggleElement.checked = data.urgency_booster_enabled;
            }
        }
    } catch (error) {
        console.error('Error loading urgency booster status:', error);
    }
}

// Toggle urgency booster global setting
async function toggleUrgencyBoosterGlobal(enabled) {
    try {
        const response = await fetch('/api/settings/urgency-booster', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ enabled: enabled })
        });
        const data = await response.json();
        
        if (!data.success) {
            alert(`‚ùå Fehler: ${data.error}`);
            document.getElementById('urgencyBoosterToggle').checked = !enabled;
        }
    } catch (error) {
        alert(`‚ùå Fehler: ${error.message}`);
        document.getElementById('urgencyBoosterToggle').checked = !enabled;
    }
}

// Load suggestions
async function loadSuggestions() {
    const btn = document.getElementById('loadSuggestionsBtn');
    const list = document.getElementById('suggestionsList');
    btn.disabled = true;
    btn.textContent = '‚è≥ Laden...';
    
    try {
        const accountSelector = document.getElementById('whitelistAccountSelector');
        const accountId = accountSelector ? accountSelector.value : null;
        
        const url = accountId ? 
            `/api/trusted-senders/suggestions?account_id=${accountId}` : 
            '/api/trusted-senders/suggestions';
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {'Content-Type': 'application/json'}
        });
        const data = await response.json();
        
        if (!data.success) {
            list.innerHTML = `<div class="alert alert-danger small mb-0">${data.error}</div>`;
            list.style.display = 'block';
            return;
        }
        
        if (data.suggestions.length === 0) {
            list.innerHTML = '<div class="text-muted">Keine Vorschl√§ge verf√ºgbar</div>';
            list.style.display = 'block';
            return;
        }
        
        list.innerHTML = data.suggestions.map((suggestion, idx) => {
            const rawSender = suggestion.sender || '';
            const safeSender = rawSender.replace(/[&<>"']/g, c => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
            }[c]));
            // Base64-encode den Rohwert, damit Quotes/<> sicher im data-Attribut landen
            const encodedSender = btoa(unescape(encodeURIComponent(rawSender)));
            const type = suggestion.suggested_pattern_type || 'exact';
            const typeDisplay = type === 'exact' ? 'Exakt' : type === 'email_domain' ? 'Domain (@)' : 'Subdomain';
            return `
            <div class="bg-dark text-light p-3 mb-2 rounded border border-info" style="background: linear-gradient(135deg, #1a2332, #0f1419) !important;">
                <div class="d-flex justify-content-between align-items-start gap-2">
                    <div style="flex-grow: 1;">
                        <div class="font-monospace small" style="color: #4ade80; font-weight: 600;">${safeSender}</div>
                        <div style="font-size: 0.75rem; color: #cbd5e1; margin-top: 4px;">
                            <span style="background: #334155; padding: 2px 6px; border-radius: 3px; display: inline-block;">${typeDisplay}</span>
                            <span style="color: #94a3b8; margin-left: 8px;">üìß ${suggestion.email_count} Email${suggestion.email_count > 1 ? 's' : ''}</span>
                        </div>
                    </div>
                    <button type="button" class="btn btn-sm btn-success suggestion-add-btn"
                            data-sender-raw="${encodedSender}"
                            data-type="${type}"
                            style="white-space: nowrap;">
                        ‚úÖ Hinzuf√ºgen
                    </button>
                </div>
            </div>
        `;
        }).join('');
        
        // Attach event listeners to all suggestion buttons
        list.querySelectorAll('.suggestion-add-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const encodedSender = this.getAttribute('data-sender-raw') || '';
                let sender = '';
                try {
                    sender = decodeURIComponent(escape(atob(encodedSender)));
                } catch (e) {
                    console.error('Decode sender failed:', e);
                    sender = '';
                }
                const type = this.getAttribute('data-type');
                addSuggestionToTrusted(sender, type);
            });
        });
        
        list.style.display = 'block';
    } catch (error) {
        list.innerHTML = `<div class="alert alert-danger small mb-0">Fehler: ${error.message}</div>`;
        list.style.display = 'block';
    } finally {
        btn.disabled = false;
        btn.textContent = 'üîç Vorschl√§ge laden';
    }
}

// Add suggestion to trusted senders (mit Account-Context)
async function addSuggestionToTrusted(pattern, type) {
    // √úbernehme den aktuell ausgew√§hlten Account
    const accountSelector = document.getElementById('whitelistAccountSelector');
    const currentAccountId = accountSelector ? accountSelector.value : '';
    
    // F√ºlle das Formular aus
    document.getElementById('trustedSenderPattern').value = pattern;
    document.getElementById('trustedSenderType').value = type;
    document.getElementById('trustedSenderLabel').value = '';
    
    // Setze den Account im Formular auf den aktuell ausgew√§hlten
    document.getElementById('trustedSenderAccountId').value = currentAccountId;
    
    // Scroll to form
    // Scroll to form - use the pattern input
    const patternInput = document.getElementById('trustedSenderPattern');
    if (patternInput) {
        patternInput.scrollIntoView({ behavior: 'smooth' });
        patternInput.focus();
    }
}

// Initialize Phase X event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Load initial data
    loadTrustedSendersList();
    loadUrgencyBoosterStatus();
    
    // Bind event listeners
    const addBtn = document.getElementById('addTrustedSenderBtn');
    if (addBtn) {
        addBtn.addEventListener('click', addTrustedSender);
    }
    
    const toggleBtn = document.getElementById('urgencyBoosterToggle');
    if (toggleBtn) {
        toggleBtn.addEventListener('change', (e) => {
            toggleUrgencyBoosterGlobal(e.target.checked);
        });
    }
    
    const suggestionsBtn = document.getElementById('loadSuggestionsBtn');
    if (suggestionsBtn) {
        suggestionsBtn.addEventListener('click', loadSuggestions);
    }
    
    // Allow Enter key in pattern input
    const patternInput = document.getElementById('trustedSenderPattern');
    if (patternInput) {
        patternInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTrustedSender();
            }
        });
    }
});
Ôªø
// ========================================
</script>
{% endblock %}
